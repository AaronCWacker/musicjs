<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test for chords1.js</title>
  <script src="abc.js"></script>
  <script src="rand.js"></script>
  <script src="rng.js"></script>
  <script src="rng-ui.js"></script>
  <script src="abc-gen.js"></script>  
  <script src="chords1.js"></script>
  <link rel="stylesheet" href="rng-ui.css">
  <script>
let rng, ui, paper, generator

window.addEventListener("load",() => {
  rng = new Rng()
  ui = new RngControls(rng,"ui")
  paper = document.getElementById("paper")
  // generator = new MyGenerator(rng,ui,paper) // generator adds its generate() callback -- later
  ui.daily()
  go()
})    
  
class Chord {
  constructor(root,rel_notes,comment=undefined) {
    this.root = root
    this.rel_notes = rel_notes
    this.comment=comment
    this.abs_notes = this.rel_notes.map((note) => ((note+this.root)%12))
    this.abs_notes.sort((x,y) => x-y)
    this.rel_notes.sort((x,y) => x-y)
    this.note_names = "C C# D D# E F F# G G# A A# B".split(" ")
  }
  print() {
    console.log(`${this.note_names[this.root]} ${this.comment}`)
  }
  same_notes_as(chord) {
    // compare this.abs_notes
    if( this.abs_notes.length != chord.abs_notes.length ) return false
    for(let i=0; i<this.abs_notes.length; i++) {
      if( this.abs_notes[i] != chord.abs_notes[i] ) return false
    }
    return true
  }
  equals(chord) {
    return this.same_notes_as(chord) && this.root == chord.root
  }
  offset(rel) {
    const chord = new Chord((this.root+rel)%12,this.rel_notes)
  }
}
// aim is to reproduce the original cs
class Conv {
  range(n) {
    return Array.from(Array(n).keys())
  }
}

const go = () => {
  const conv = new Conv()
  const indices = conv.range(12)
  const major_chord_notes = [0,4,7]
  const minor_chord_notes = [0,3,7]
  const major_chords = indices.map(root => new Chord(root,major_chord_notes,"major"))
  const minor_chords = indices.map(root => new Chord(root,minor_chord_notes,"minor"))
  // for each index, we want a list of chords containing that note
  const chords_containing_note = indices.map(_ => Array())
  major_chords.forEach(chord => {
    chord.abs_notes.forEach(note => {
      chords_containing_note[note].push(chord)
    })
  })
  minor_chords.forEach(chord => {
    chord.abs_notes.forEach(note => {
      chords_containing_note[note].push(chord)
    })
  })

  // choose first chord
  const starting_index = rng.rand_choice(indices)
  const first_chord_index = rng.rand_range(6)
  let current_chord = chords_containing_note[starting_index][first_chord_index]
  console.log({starting_index,first_chord_index,current_chord})

  let new_pivot, new_chord

  const cb = (chord) => {
    console.log({chord})
  }

  for(let i=0; i<10; i++) {
    new_pivot = rng.rand_choice(current_chord.abs_notes)
    const candidates = chords_containing_note[new_pivot].filter(x => !current_chord.same_notes_as(x))
    //console.log(candidates.length)
    new_chord = rng.rand_choice(candidates)
    new_chord.print()
    current_chord = new_chord
  }

}  
</script>
</head>
<body>
  <div id="ui"></div>
  <div id="paper"></div>
</body>
</html>